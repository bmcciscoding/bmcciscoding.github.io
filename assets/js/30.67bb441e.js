(window.webpackJsonp=window.webpackJsonp||[]).push([[30],{495:function(t,r,a){"use strict";a.r(r);var e=a(10),s=Object(e.a)({},(function(){var t=this,r=t.$createElement,a=t._self._c||r;return a("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[a("h1",{attrs:{id:"前因"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#前因"}},[t._v("#")]),t._v(" 前因")]),t._v(" "),a("p",[t._v("HTTP 是明文传输，不安全。既然如此，很自然想到用密文传输。常见的加密都是对称加密，即双方之间约定好加密规则，然后再进行通信。但是如果加密规则泄漏了，还是明文传输。所以问题就变成了如何告知对方加密规则。前人选择的方式是使用非对称加密。\n加密方和解密房使用不用的密钥。")]),t._v(" "),a("h1",{attrs:{id:"https-的流程"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#https-的流程"}},[t._v("#")]),t._v(" HTTPS 的流程")]),t._v(" "),a("p",[t._v("1、Client 发送 https 请求到 Server\n2、Server 把带有自己公钥的CA证书发回给 Client\n3、Client 验证证书\n4、如果证书是合法，Client 确定对称加密算法和生成对称密钥，发回给 Server\n5、Server 用自己的私钥解密，拿到对称加密算法和密钥\n6、之后的通信使用对称加密进行")]),t._v(" "),a("h1",{attrs:{id:"疑问"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#疑问"}},[t._v("#")]),t._v(" 疑问")]),t._v(" "),a("p",[t._v("根据以上流程，有以下几点疑问：\n1、为什么 Server 要把自己的公钥放到CA证书里？\n2、Client 如何验证")]),t._v(" "),a("h1",{attrs:{id:"非对称加密"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#非对称加密"}},[t._v("#")]),t._v(" 非对称加密")]),t._v(" "),a("h1",{attrs:{id:"ca、数字证书、数字签名"}},[a("a",{staticClass:"header-anchor",attrs:{href:"#ca、数字证书、数字签名"}},[t._v("#")]),t._v(" CA、数字证书、数字签名")])])}),[],!1,null,null,null);r.default=s.exports}}]);