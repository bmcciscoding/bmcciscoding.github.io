(window.webpackJsonp=window.webpackJsonp||[]).push([[20],{483:function(t,e,o){"use strict";o.r(e);var r=o(10),a=Object(r.a)({},(function(){var t=this,e=t.$createElement,o=t._self._c||e;return o("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[o("p",[t._v("React 有 Redux，Vue 有 Vuex。\b状态管理在 Web 端是什么重要的功能。但是在 iOS 上，缺没有一统江湖的框架。ReactorKit 试图在做这样事，但是也直接套用 Web 的思想，也会有些水土不服反应。")]),t._v(" "),o("p",[t._v("ReactorKit 并不推崇全局唯一的 store，甚至一个 ViewController 搭配一个 Reactor 也是十分和谐的。但是多 Reactor 的方案也带来了数据同步性的难题。比如说，\n从 A 页面进入 B 页面打字搜索，输入完成后，A 界面发送请求。如果用多 Reactor 的方案，写起来就十分难受，因为并没有一个 global state 可以同步这些变化。但是一旦打开 global state，预感就会造成泛滥，会造成多个 reactor 都需要访问这些 global state，反而不如直接使用单 reactor 方案。")]),t._v(" "),o("p",[t._v("Reactor 最初的考虑是最小侵入性，让接入很友好。因此，我觉得如果一开始就打算使用 Reactor 来枸酱整个 App，还是使用单 Reactor 方案。毕竟 Redux 和 Vuex 也提供最佳实践。")]),t._v(" "),o("p",[t._v("可是如果使用单 Reactor 方案，如何拆分实现代码又是一个问题，总不能都写在一个文件里，成就上万行代码。")])])}),[],!1,null,null,null);e.default=a.exports}}]);